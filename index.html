<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç›²äººäº¤é€šè¾…åŠ©ç³»ç»Ÿ</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: Arial, sans-serif; 
            background: #000;
            color: white;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* è¶…å¤§æŒ‰é’®æ ·å¼ */
        .control-button {
            flex: 1;
            font-size: 2.5rem;
            border: none;
            color: white;
            cursor: pointer;
            transition: background-color 0.3s;
            min-height: 50vh;
        }
        
        #startBtn {
            background: #28a745;
        }
        
        #startBtn:active {
            background: #218838;
        }
        
        #stopBtn {
            background: #dc3545;
        }
        
        #stopBtn:active {
            background: #c82333;
        }
        
        button:disabled {
            background: #6c757d !important;
            cursor: not-allowed;
        }
        
        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .status-indicator {
            height: 20px;
            background: #6c757d;
            transition: background-color 0.3s;
        }
        
        .status-running {
            background: #28a745;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <!-- å¯åŠ¨æŒ‰é’® - è¶…å¤§ï¼Œä½äºä¸Šæ–¹ -->
    <button id="startBtn" class="control-button">
        ğŸŸ¢ å¯åŠ¨è¾…åŠ©ç³»ç»Ÿ
    </button>
    
    <!-- çŠ¶æ€æŒ‡ç¤ºæ¡ -->
    <div id="statusIndicator" class="status-indicator"></div>
    
    <!-- åœæ­¢æŒ‰é’® - è¶…å¤§ï¼Œä½äºä¸‹æ–¹ -->
    <button id="stopBtn" class="control-button" disabled>
        ğŸ”´ åœæ­¢ç³»ç»Ÿ
    </button>

    <script>
        // ç³»ç»Ÿå˜é‡
        let isRunning = false;
        let aiModel = null;
        let cameraStream = null;
        let analysisInterval = null;
        
        // DOMå…ƒç´ 
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const statusIndicator = document.getElementById('statusIndicator');
        
        // å±é™©ç‰©ä½“åˆ—è¡¨
        const dangerousObjects = ['car', 'truck', 'bus', 'motorcycle', 'bicycle', 'person'];
        
        // å¯åŠ¨ç³»ç»Ÿ
        startBtn.addEventListener('click', async () => {
            try {
                startBtn.disabled = true;
                speak("æ­£åœ¨å¯åŠ¨äº¤é€šè¾…åŠ©ç³»ç»Ÿ");
                
                // åŠ è½½AIæ¨¡å‹
                aiModel = await cocoSsd.load();
                
                // è¯·æ±‚æ‘„åƒå¤´æƒé™
                speak("æ­£åœ¨å¼€å¯æ‘„åƒå¤´");
                cameraStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                
                // å¼€å§‹åˆ†æ
                startAnalysis();
                
                // æ›´æ–°UI
                stopBtn.disabled = false;
                isRunning = true;
                statusIndicator.classList.add('status-running');
                speak("ç³»ç»Ÿå·²å¯åŠ¨ï¼Œå¼€å§‹æ£€æµ‹å‘¨å›´ç¯å¢ƒ");
                
            } catch (error) {
                console.error('å¯åŠ¨å¤±è´¥:', error);
                speak("å¯åŠ¨å¤±è´¥ï¼Œè¯·é‡è¯•");
                startBtn.disabled = false;
            }
        });
        
        // åœæ­¢ç³»ç»Ÿ
        stopBtn.addEventListener('click', () => {
            stopAnalysis();
            startBtn.disabled = false;
            stopBtn.disabled = true;
            isRunning = false;
            statusIndicator.classList.remove('status-running');
            speak("ç³»ç»Ÿå·²åœæ­¢");
        });
        
        // å¼€å§‹ç¯å¢ƒåˆ†æ
        function startAnalysis() {
            analysisInterval = setInterval(async () => {
                if (!aiModel) return;
                
                try {
                    // åˆ›å»ºä¸´æ—¶è§†é¢‘å…ƒç´ åˆ†æç”»é¢
                    const video = document.createElement('video');
                    video.srcObject = cameraStream;
                    video.play();
                    
                    await new Promise(resolve => video.onloadeddata = resolve);
                    
                    // æ£€æµ‹ç‰©ä½“
                    const predictions = await aiModel.detect(video);
                    
                    // å¤„ç†æ£€æµ‹ç»“æœ
                    processDetections(predictions);
                    
                } catch (error) {
                    console.error('åˆ†æå¤±è´¥:', error);
                }
            }, 1500); // æ¯1.5ç§’åˆ†æä¸€æ¬¡
        }
        
        // å¤„ç†æ£€æµ‹ç»“æœ
        function processDetections(predictions) {
            const dangerousItems = predictions.filter(pred => 
                dangerousObjects.includes(pred.class) && pred.score > 0.6
            );
            
            if (dangerousItems.length > 0) {
                // æ ¹æ®å±é™©ç¨‹åº¦æ’åºï¼ˆåˆ†æ•°é«˜çš„ä¼˜å…ˆï¼‰
                dangerousItems.sort((a, b) => b.score - a.score);
                
                const mainThreat = dangerousItems[0];
                const threatLevel = calculateThreatLevel(mainThreat);
                
                // è§¦è§‰åé¦ˆ - éœ‡åŠ¨
                triggerVibration(threatLevel);
                
                // è¯­éŸ³æç¤º
                if (threatLevel === 'high') {
                    speak(`è­¦å‘Šï¼Œå‰æ–¹æœ‰${getChineseName(mainThreat.class)}é è¿‘`);
                } else if (threatLevel === 'medium') {
                    speak(`æ³¨æ„ï¼Œé™„è¿‘æœ‰${getChineseName(mainThreat.class)}`);
                }
            }
        }
        
        // è®¡ç®—å¨èƒç­‰çº§
        function calculateThreatLevel(detection) {
            // åŸºäºæ£€æµ‹æ¡†å¤§å°å’Œç½®ä¿¡åº¦è®¡ç®—å¨èƒç­‰çº§
            const area = detection.bbox[2] * detection.bbox[3]; // å®½ * é«˜
            const score = detection.score;
            
            if (area > 0.3 && score > 0.8) return 'high';    // å¤§ä¸”ç½®ä¿¡åº¦é«˜
            if (area > 0.1 && score > 0.6) return 'medium';  // ä¸­ç­‰
            return 'low';                                     // ä½å¨èƒ
        }
        
        // è§¦å‘éœ‡åŠ¨åé¦ˆ
        function triggerVibration(threatLevel) {
            if (navigator.vibrate) {
                switch (threatLevel) {
                    case 'high':
                        navigator.vibrate([500, 100, 500]); // å¼ºçƒˆéœ‡åŠ¨
                        break;
                    case 'medium':
                        navigator.vibrate([300, 100, 300]); // ä¸­ç­‰éœ‡åŠ¨
                        break;
                    case 'low':
                        navigator.vibrate(200); // çŸ­éœ‡åŠ¨
                        break;
                }
            }
        }
        
        // è¯­éŸ³æ’­æŠ¥
        function speak(text) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'zh-CN';
                utterance.rate = 0.9; // ç¨æ…¢çš„è¯­é€Ÿ
                speechSynthesis.speak(utterance);
            }
        }
        
        // è·å–ä¸­æ–‡åç§°
        function getChineseName(className) {
            const nameMap = {
                'car': 'æ±½è½¦',
                'truck': 'å¡è½¦',
                'bus': 'å…¬äº¤è½¦',
                'motorcycle': 'æ‘©æ‰˜è½¦',
                'bicycle': 'è‡ªè¡Œè½¦',
                'person': 'è¡Œäºº'
            };
            return nameMap[className] || className;
        }
        
        // åœæ­¢åˆ†æ
        function stopAnalysis() {
            if (analysisInterval) clearInterval(analysisInterval);
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
        }
        
        // é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
        window.addEventListener('beforeunload', () => {
            if (isRunning) stopAnalysis();
        });
        
        // åˆå§‹åŒ–è¯­éŸ³æç¤º
        window.addEventListener('load', () => {
            setTimeout(() => {
                speak("äº¤é€šè¾…åŠ©ç³»ç»Ÿå·²å‡†å¤‡å°±ç»ªï¼Œè¯·ç‚¹å‡»ä¸Šæ–¹ç»¿è‰²åŒºåŸŸå¯åŠ¨");
            }, 1000);
        });
    </script>
</body>
</html>
